
import re


def parse_schema(input_file, output_file):
    with open(input_file, 'r', encoding='utf-8', errors='ignore') as f_in:
        sql_content = f_in.read()

    # Pre-processing cleanup
    # Remove comment lines
    sql_content = re.sub(r'/\*!.*?\*/;', '', sql_content)
    sql_content = re.sub(r'--.*?\n', '', sql_content)
    
    # 1. Remove table options (ENGINE, CHARSET, etc.) at the end of CREATE TABLE
    # Matches ) ENGINE=... ; and replaces with );
    sql_content = re.sub(r'\)\s*ENGINE=\w+\s+AUTO_INCREMENT=\d+\s+DEFAULT\s+CHARSET=\w+;', ');', sql_content)
    sql_content = re.sub(r'\)\s*ENGINE=\w+\s+DEFAULT\s+CHARSET=\w+;', ');', sql_content)
    
    # 2. Convert identifiers
    sql_content = sql_content.replace('`', '"')
    

    # 3. Data Types
    # Use word boundaries to avoid partial matches (e.g. matching int inside tinyint)
    # Specific requirement: TinyInt(1) -> Boolean
    sql_content = re.sub(r'\btinyint\(1\)', 'boolean', sql_content)
    sql_content = re.sub(r'\btinyint\(\d+\)', 'smallint', sql_content)
    sql_content = re.sub(r'\btinyint\b', 'smallint', sql_content)
    sql_content = re.sub(r'\bint\(\d+\)', 'integer', sql_content)
    sql_content = re.sub(r'\bmediumtext\b', 'text', sql_content)
    sql_content = re.sub(r'\blongtext\b', 'text', sql_content)
    sql_content = re.sub(r'\bdouble\(\d+,\d+\)', 'double precision', sql_content)
    sql_content = re.sub(r'\bdatetime\b', 'timestamp', sql_content)
    
    # Handle unsigned
    # integer unsigned -> bigint
    sql_content = re.sub(r'\binteger\s+unsigned\b', 'bigint', sql_content)
    # smallint unsigned -> integer
    sql_content = re.sub(r'\bsmallint\s+unsigned\b', 'integer', sql_content)
    
    # 4. Auto Increment
    # MySQL: id integer AUTO_INCREMENT

    # PG: id integer GENERATED BY DEFAULT AS IDENTITY
    sql_content = sql_content.replace('AUTO_INCREMENT', 'GENERATED BY DEFAULT AS IDENTITY')
    
    # Handle Unsigned Integers (Postgres doesn't support UNSIGNED)
    # Map to next larger type to ensure fit, or same type if acceptable
    sql_content = re.sub(r'tinyint\(\d+\) unsigned', 'smallint', sql_content, flags=re.IGNORECASE)
    sql_content = re.sub(r'smallint\(\d+\) unsigned', 'integer', sql_content, flags=re.IGNORECASE)
    sql_content = re.sub(r'int\(\d+\) unsigned', 'bigint', sql_content, flags=re.IGNORECASE)
    sql_content = re.sub(r'bigint\(\d+\) unsigned', 'numeric(20)', sql_content, flags=re.IGNORECASE)
    
    # Remove display widths from integer types
    sql_content = re.sub(r'tinyint\(\d+\)', 'smallint', sql_content, flags=re.IGNORECASE)
    sql_content = re.sub(r'smallint\(\d+\)', 'smallint', sql_content, flags=re.IGNORECASE)
    sql_content = re.sub(r'int\(\d+\)', 'integer', sql_content, flags=re.IGNORECASE)
    sql_content = re.sub(r'bigint\(\d+\)', 'bigint', sql_content, flags=re.IGNORECASE)
    pg_statements = []
    fk_statements = []
    
    for stmt in statements:
        if 'CREATE TABLE' in stmt.upper():
            # Process inside of CREATE TABLE
            lines = stmt.split('\n')
            new_lines = []
            indexes = []
            
            # Find table name by searching the whole statement first, not just lines[0]
            # Because lines[0] might be empty due to split
            table_name = "unknown_table"
            search_match = re.search(r'CREATE TABLE "(\w+)"', stmt)
            if search_match:
                table_name = search_match.group(1)

            for line in lines:
                line = line.strip()
                if not line:
                    continue
                
                # Handle KEY and UNIQUE KEY lines
                if line.startswith('UNIQUE KEY'):
                    m = re.match(r'UNIQUE KEY "(\w+)" \((.*?)\)', line)
                    if m:
                        constraint_name = m.group(1)
                        cols = m.group(2)
                        new_lines.append(f'CONSTRAINT "{constraint_name}" UNIQUE ({cols})')
                elif line.startswith('KEY'):
                    m = re.match(r'KEY "(\w+)" \((.*?)\)', line)
                    if m:
                        index_name = m.group(1)
                        cols = m.group(2)
                        indexes.append(f'CREATE INDEX "{index_name}" ON "{table_name}" ({cols});')
                elif line.startswith('CONSTRAINT'):
                    # Check if it's a FOREIGN KEY
                    if 'FOREIGN KEY' in line:
                         # Extract the constraint to add later
                         # Format: CONSTRAINT "name" FOREIGN KEY ("col") REFERENCES "other_table" ("other_col")
                         # We need to remove the trailing comma if present
                         if line.endswith(','):
                             line = line[:-1]
                         
                         fk_stmt = f'ALTER TABLE "{table_name}" ADD {line};'
                         fk_statements.append(fk_stmt)
                    else:
                        new_lines.append(line)
                elif 'PRIMARY KEY' in line:
                    new_lines.append(line)
                elif line.startswith('CREATE TABLE'):
                    new_lines.append(line)
                elif line.startswith(')'):
                    new_lines.append(');')
                else:
                    if line.endswith(','):
                        line = line[:-1]
                    new_lines.append(line + ',')

            # Reassemble table
            # Fix trailing comma on last column/constraint
            if new_lines and new_lines[-1] == ');':
                 if len(new_lines) > 2:
                     if new_lines[-2].endswith(','):
                         new_lines[-2] = new_lines[-2][:-1]
            
            pg_stmt = '\n'.join(new_lines)
            pg_statements.append(pg_stmt)
            pg_statements.extend(indexes)
            
    # Combine tables + indexes + foreign keys
    final_output = pg_statements + fk_statements
    
    with open(output_file, 'w', encoding='utf-8') as f_out:
        f_out.write('\n\n'.join(final_output))
    
    print(f"Extracted tables, indexes and {len(fk_statements)} FK constraints to {output_file}")

if __name__ == '__main__':
    parse_schema('database_full_2026.sql', 'schema_pg_converted.sql')
